5. Write a program to illustrate the following IPC mechanisms

5(a) Pipes

Aim:
To illustrate Inter-Process Communication (IPC) using pipes, where a parent process writes a message, and a child process reads and prints it.

Algorithm:
1. Start the program.
2. Create a pipe using the pipe() system call.
3. Fork a child process using the fork() system call.
4. In the child process:
   a. Close the write end of the pipe.
   b. Read the message from the pipe.
   c. Print the received message.
   d. Close the read end of the pipe.
5. In the parent process:
   a. Close the read end of the pipe.
   b. Prompt the user for a message.
   c. Write the message to the pipe.
   d. Close the write end of the pipe.
6. Wait for the child process to complete.
7. End the program.

Expected Output:
Enter a message: Hello IPC Pipes
Child process received: Hello IPC Pipes

---

5(b) FIFOs (Named Pipes)

Aim:
To illustrate IPC using FIFOs (Named Pipes), where a parent writes a message into a FIFO, and a child reads and prints it.

Algorithm:
1. Start the program.
2. Create a FIFO using the mkfifo() system call.
3. Fork a child process using the fork() system call.
4. In the child process:
   a. Open the FIFO for reading.
   b. Read the message from the FIFO.
   c. Print the received message.
   d. Close the FIFO.
5. In the parent process:
   a. Open the FIFO for writing.
   b. Prompt the user for a message.
   c. Write the message to the FIFO.
   d. Close the FIFO.
6. Wait for the child process to complete.
7. Delete the FIFO file using unlink().
8. End the program.

Expected Output:
Enter a message: Hello from FIFO
Child process received: Hello from FIFO

---

5(c) Message Queues

Aim:
To illustrate IPC using message queues, where a parent process sends a message to a queue, and a child process reads and prints it.

Algorithm:
1. Start the program.
2. Create a message queue using the msgget() system call.
3. Define a message structure with a message type and text.
4. Fork a child process using the fork() system call.
5. In the child process:
   a. Receive the message from the message queue using msgrcv().
   b. Print the received message.
   c. Delete the message queue using msgctl().
6. In the parent process:
   a. Prompt the user for a message.
   b. Send the message to the message queue using msgsnd().
7. Wait for the child process to complete.
8. End the program.

Expected Output:
Enter a message: Hi Message Queue
Child process received: Hi Message Queue

---

5(d) Shared Memory

Aim:
To illustrate IPC using Shared Memory, where a parent process writes data to shared memory, and a child process reads and prints it.

Algorithm:
Algorithm for Writer Process:
1. Generate a unique key using ftok().
2. Create shared memory using shmget().
3. Attach shared memory using shmat().
4. Prompt the user for input and write data into shared memory.
5. Detach from shared memory using shmdt().

Algorithm for Reader Process:
1. Generate a unique key using ftok().
2. Access shared memory using shmget().
3. Attach to shared memory using shmat().
4. Read and print the data from shared memory.
5. Detach from shared memory using shmdt().
6. Remove shared memory using shmctl().

Expected Output:
Write Data: Hello from shared memory!
Data written in memory: Hello from shared memory!
Child process received: Hello from shared memory!

---

5(d) Shared Memory

Aim:
To illustrate IPC using Shared Memory, where a parent process writes data to shared memory, and a child process reads and prints it.

Algorithm:

Algorithm for Writer Process:
1. Generate a unique key using ftok().
2. Create shared memory using shmget().
3. Attach shared memory using shmat().
4. Prompt the user for input and write data into shared memory.
5. Detach from shared memory using shmdt().

Algorithm for Reader Process:
1. Generate a unique key using ftok().
2. Access shared memory using shmget().
3. Attach to shared memory using shmat().
4. Read and print the data from shared memory.
5. Detach from shared memory using shmdt().
6. Remove shared memory using shmctl

Expected Output:
Write Data: Hello from shared memory!
Data written in memory: Hello from shared memory!
Child process received: Hello from shared memory!

---

Conclusion:
- Pipes: Unidirectional communication between parent and child processes.
- FIFOs (Named Pipes): Allows communication between unrelated processes.
- Message Queues: Supports structured message passing with persistence.
- Shared Memory: Fastest IPC but requires synchronization.

Each IPC mechanism serves a unique purpose in process communication.
